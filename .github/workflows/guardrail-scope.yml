name: "Guardrail: Scope Enforcement"

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  checks: write
  issues: read
  pull-requests: read
  contents: read

jobs:
  scope-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: .github/agent-workflow

      - name: Check scope enforcement
        uses: actions/github-script@v7
        with:
          script: |
            const checkName = 'guardrail/scope';

            // --- Helper: read config ---
            async function readConfig() {
              try {
                const { data } = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: '.github/agent-workflow/config.yaml',
                  ref: context.payload.pull_request.head.sha
                });
                const content = Buffer.from(data.content, 'base64').toString('utf-8');
                // Simple YAML parsing for the scope-enforcement section
                const lines = content.split('\n');
                let inScope = false;
                const config = { enabled: true, conclusion: 'action_required' };
                for (const line of lines) {
                  if (/^scope-enforcement:/.test(line)) {
                    inScope = true;
                    continue;
                  }
                  if (inScope && /^\S/.test(line)) {
                    break; // Next top-level key
                  }
                  if (inScope) {
                    const enabledMatch = line.match(/^\s+enabled:\s*(true|false)/);
                    if (enabledMatch) config.enabled = enabledMatch[1] === 'true';
                    const conclusionMatch = line.match(/^\s+conclusion:\s*(\S+)/);
                    if (conclusionMatch) config.conclusion = conclusionMatch[1];
                  }
                }
                return config;
              } catch (e) {
                // Config file not found — use defaults (enabled)
                return { enabled: true, conclusion: 'action_required' };
              }
            }

            // --- Helper: create check run ---
            async function createCheckRun(conclusion, title, summary, annotations = []) {
              const output = { title, summary };
              if (annotations.length > 0) {
                // GitHub API limits to 50 annotations per request
                output.annotations = annotations.slice(0, 50);
              }
              await github.rest.checks.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head_sha: context.payload.pull_request.head.sha,
                name: checkName,
                status: 'completed',
                conclusion,
                output
              });
            }

            // --- Step 1: Read config and check if enabled ---
            const config = await readConfig();
            if (!config.enabled) {
              await createCheckRun(
                'success',
                'Scope enforcement: disabled',
                'Scope enforcement is disabled in agent-workflow config.'
              );
              return;
            }

            // --- Step 2: Check for non-stale PR approval override ---
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            const headSha = context.payload.pull_request.head.sha;
            const hasValidApproval = reviews.data.some(
              r => r.state === 'APPROVED' && r.commit_id === headSha
            );

            // --- Step 3: Parse issue reference from PR body ---
            const prBody = context.payload.pull_request.body || '';
            const issueMatch = prBody.match(/[Ff]ixes\s+#(\d+)/);
            if (!issueMatch) {
              // No linked issue — cannot enforce scope, pass with note
              await createCheckRun(
                'success',
                'Scope enforcement: no linked issue',
                'No `fixes #N` reference found in PR description. Scope enforcement skipped.'
              );
              return;
            }
            const issueNumber = parseInt(issueMatch[1], 10);

            // --- Step 4: Get the issue body + all child issue bodies ---
            // File paths may be listed in the parent issue, its child issues, or both.
            // Collect bodies from the parent and all sub-issues.
            const issueBodies = [];
            try {
              const issue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              issueBodies.push(issue.data.body || '');
            } catch (e) {
              await createCheckRun(
                'success',
                'Scope enforcement: issue not found',
                `Could not read issue #${issueNumber}. Scope enforcement skipped.`
              );
              return;
            }

            // Query sub-issues via GraphQL
            try {
              const subIssueResult = await github.graphql(`
                query($owner: String!, $repo: String!, $number: Int!) {
                  repository(owner: $owner, name: $repo) {
                    issue(number: $number) {
                      subIssues(first: 50) {
                        nodes { body }
                      }
                    }
                  }
                }
              `, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                number: issueNumber
              });
              const children = subIssueResult.repository.issue.subIssues.nodes || [];
              for (const child of children) {
                if (child.body) issueBodies.push(child.body);
              }
            } catch (e) {
              // Sub-issues query failed — continue with parent body only
            }

            // --- Step 5: Extract file paths from all issue bodies ---
            // Match paths that look like file paths:
            //   - backtick-wrapped paths: `src/foo/bar.ts`
            //   - paths with extensions: src/foo/bar.ts
            //   - paths in markdown code blocks
            const filePathPatterns = [
              // Backtick-wrapped paths with extension
              /`([a-zA-Z0-9_./-]+\.[a-zA-Z0-9]+)`/g,
              // Bare paths with at least one slash and an extension (common in issue descriptions)
              /(?:^|\s)((?:[a-zA-Z0-9_.-]+\/)+[a-zA-Z0-9_.-]+\.[a-zA-Z0-9]+)(?:\s|$|[,;)])/gm,
              // Paths starting with ./ or common root dirs
              /(?:^|\s)(\.?(?:src|lib|app|test|tests|spec|pkg|cmd|internal|\.github)\/[a-zA-Z0-9_./-]+)(?:\s|$|[,;)])/gm
            ];

            const scopeFiles = new Set();
            for (const body of issueBodies) {
              for (const pattern of filePathPatterns) {
                pattern.lastIndex = 0; // reset regex state for each body
                let match;
                while ((match = pattern.exec(body)) !== null) {
                  const filePath = match[1].replace(/^\//, ''); // strip leading slash
                  scopeFiles.add(filePath);
                }
              }
            }

            if (scopeFiles.size === 0) {
              // No file paths found in any issue — cannot enforce scope
              await createCheckRun(
                'success',
                'Scope enforcement: no files listed in issues',
                `Issue #${issueNumber} and its children do not list any file paths. Scope enforcement skipped.`
              );
              return;
            }

            // --- Step 6: Get changed files from the PR ---
            const changedFiles = [];
            let page = 1;
            while (true) {
              const resp = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                per_page: 100,
                page
              });
              changedFiles.push(...resp.data);
              if (resp.data.length < 100) break;
              page++;
            }

            // --- Step 7: Compare changed files against scope ---
            // A changed file is "in scope" if:
            //   - It exactly matches a scope file, OR
            //   - It is inside a directory listed in scope, OR
            //   - A scope file is a prefix of the changed file path
            function isInScope(changedPath) {
              for (const scopePath of scopeFiles) {
                // Exact match
                if (changedPath === scopePath) return true;
                // Scope entry is a directory prefix (e.g., scope lists "src/auth/",
                // changed file is "src/auth/middleware.ts")
                if (changedPath.startsWith(scopePath.endsWith('/') ? scopePath : scopePath + '/')) return true;
              }
              return false;
            }

            const outOfScope = changedFiles.filter(f => !isInScope(f.filename));

            // --- Step 8: Report results ---
            if (outOfScope.length === 0) {
              await createCheckRun(
                'success',
                'Scope enforcement: all files in scope',
                `All ${changedFiles.length} changed files are within scope of issue #${issueNumber} and its children.`
              );
              return;
            }

            // There are out-of-scope files
            if (hasValidApproval) {
              await createCheckRun(
                'success',
                `Scope enforcement: approved by reviewer (${outOfScope.length} files outside scope)`,
                `PR modifies ${outOfScope.length} file(s) not listed in issue #${issueNumber} or its children, but a non-stale approval exists.\n\nOut-of-scope files:\n${outOfScope.map(f => '- `' + f.filename + '`').join('\n')}`
              );
              return;
            }

            // Build annotations for out-of-scope files
            const annotations = outOfScope.map(f => ({
              path: f.filename,
              start_line: 1,
              end_line: 1,
              annotation_level: 'warning',
              message: `This file is not listed in the task scope for issue #${issueNumber} or its children. If this change is intentional, approve the PR to override.`
            }));

            // Determine conclusion based on config and severity
            // Minor: 1-2 files out of scope; Significant: 3+
            const isMinor = outOfScope.length <= 2;
            const conclusion = isMinor ? 'neutral' : config.conclusion;

            const summary = [
              `PR modifies ${outOfScope.length} file(s) not listed in issue #${issueNumber} or its children.`,
              '',
              '**Out-of-scope files:**',
              ...outOfScope.map(f => `- \`${f.filename}\``),
              '',
              `**In-scope files (from issues):**`,
              ...[...scopeFiles].map(f => `- \`${f}\``),
              '',
              'To resolve: either update the issue to include these files, or approve the PR to override this check.'
            ].join('\n');

            await createCheckRun(
              conclusion,
              `Scope enforcement: ${outOfScope.length} file(s) outside task scope`,
              summary,
              annotations
            );

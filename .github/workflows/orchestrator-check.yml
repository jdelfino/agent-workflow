name: Orchestrator Status Check

"on":
  issues:
    types: [opened, closed, labeled, unlabeled]
  pull_request:
    types: [synchronize]

permissions:
  checks: write
  issues: read
  pull-requests: read
  contents: read
  actions: write

jobs:
  orchestrator:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: .github/agent-workflow
          fetch-depth: 0

      - name: Orchestrator check
        uses: actions/github-script@v7
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        with:
          script: |
            const checkName = 'orchestrator';

            // ── Helper: read re-review-cycle-cap from config ────────────
            async function readCycleCap() {
              try {
                const { data } = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: '.github/agent-workflow/config.yaml',
                  ref: context.sha
                });
                const content = Buffer.from(data.content, 'base64').toString('utf-8');
                const match = content.match(/^re-review-cycle-cap:\s*(\d+)/m);
                return match ? parseInt(match[1], 10) : 3;
              } catch {
                return 3; // default
              }
            }

            // ── Helper: create check run on a specific SHA ──────────────
            async function createCheckRun(headSha, conclusion, title, summary) {
              await github.rest.checks.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head_sha: headSha,
                name: checkName,
                status: 'completed',
                conclusion,
                output: { title, summary }
              });
            }

            // ── Helper: find PRs referencing a given issue ──────────────
            // Searches open PRs whose body contains "Fixes #N" or "fixes #N"
            async function findPRsForIssue(issueNumber) {
              const prs = [];
              let page = 1;
              while (true) {
                const resp = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  per_page: 100,
                  page
                });
                if (resp.data.length === 0) break;
                for (const pr of resp.data) {
                  const body = pr.body || '';
                  const regex = new RegExp(`[Ff]ixes\\s*#${issueNumber}\\b`);
                  if (regex.test(body)) {
                    prs.push(pr);
                  }
                }
                if (resp.data.length < 100) break;
                page++;
              }
              return prs;
            }

            // ── Helper: query sub-issues via GraphQL ────────────────────
            async function getSubIssues(issueNumber) {
              const query = `
                query($owner: String!, $repo: String!, $number: Int!) {
                  repository(owner: $owner, name: $repo) {
                    issue(number: $number) {
                      subIssues(first: 50) {
                        nodes {
                          number
                          title
                          state
                          labels(first: 10) { nodes { name } }
                        }
                      }
                    }
                  }
                }
              `;
              try {
                const result = await github.graphql(query, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  number: issueNumber
                });
                return result.repository.issue.subIssues.nodes;
              } catch (err) {
                console.log(`Warning: GraphQL sub-issues query failed: ${err.message}`);
                return [];
              }
            }

            // ── Helper: count past review cycles from PR comments ───────
            // We count comments left by the pr-review workflow (bot) that
            // indicate a review cycle was triggered.
            async function countReviewCycles(prNumber) {
              const comments = await github.paginate(
                github.rest.issues.listComments,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  per_page: 100
                }
              );
              // Count comments that contain the re-review marker
              return comments.filter(
                c => c.body && c.body.includes('<!-- orchestrator-review-cycle -->')
              ).length;
            }

            // ── Step 1: Determine the parent issue and PR ───────────────
            let parentIssueNumber;
            let prNumber;
            let headSha;

            if (context.eventName === 'pull_request') {
              // PR synchronize event — parse parent issue from PR body
              const pr = context.payload.pull_request;
              prNumber = pr.number;
              headSha = pr.head.sha;
              const body = pr.body || '';
              const fixesMatch = body.match(/[Ff]ixes\s*#(\d+)/);
              if (!fixesMatch) {
                console.log('No "Fixes #N" in PR body. Skipping orchestrator check.');
                await createCheckRun(
                  headSha,
                  'neutral',
                  'Orchestrator: no linked issue',
                  'No `Fixes #N` reference found in PR description. Orchestrator check skipped.'
                );
                return;
              }
              parentIssueNumber = parseInt(fixesMatch[1], 10);

            } else if (context.eventName === 'issues') {
              // Issue event — find the PR that references this issue's parent
              // The changed issue might BE a sub-issue (review finding).
              // We need to find which parent issue it belongs to, then find the PR.
              const changedIssue = context.payload.issue;

              // Strategy: search for open PRs that reference this issue or any
              // issue that is a parent of this issue. Since sub-issues are children
              // of the parent issue, and the PR has "Fixes #parent", we need to
              // find PRs referencing any issue. We search for PRs that reference
              // issues that have this changed issue as a sub-issue.
              //
              // Simpler approach: search all open PRs for ones containing
              // "Fixes #N" and then check if the changed issue is a sub-issue of N.
              // But that's expensive.
              //
              // Practical approach: list all open PRs, parse their "Fixes #N",
              // check if the changed issue is a sub-issue of any of those N values.

              const openPRs = [];
              let page = 1;
              while (true) {
                const resp = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  per_page: 100,
                  page
                });
                if (resp.data.length === 0) break;
                openPRs.push(...resp.data);
                if (resp.data.length < 100) break;
                page++;
              }

              // Build a map of parent issue number -> PR data
              const parentToPR = new Map();
              for (const pr of openPRs) {
                const body = pr.body || '';
                const match = body.match(/[Ff]ixes\s*#(\d+)/);
                if (match) {
                  parentToPR.set(parseInt(match[1], 10), pr);
                }
              }

              if (parentToPR.size === 0) {
                console.log('No open PRs with "Fixes #N" references found. Nothing to do.');
                return;
              }

              // Check if the changed issue IS a parent issue referenced by a PR
              if (parentToPR.has(changedIssue.number)) {
                parentIssueNumber = changedIssue.number;
                const pr = parentToPR.get(changedIssue.number);
                prNumber = pr.number;
                headSha = pr.head.sha;
              } else {
                // Check if the changed issue is a sub-issue of any parent
                let found = false;
                for (const [parentNum, pr] of parentToPR.entries()) {
                  const subIssues = await getSubIssues(parentNum);
                  const isChild = subIssues.some(
                    si => si.number === changedIssue.number
                  );
                  if (isChild) {
                    parentIssueNumber = parentNum;
                    prNumber = pr.number;
                    headSha = pr.head.sha;
                    found = true;
                    break;
                  }
                }
                if (!found) {
                  console.log(
                    `Issue #${changedIssue.number} is not a sub-issue of any PR-linked parent. Nothing to do.`
                  );
                  return;
                }
              }
            } else {
              console.log(`Unexpected event: ${context.eventName}. Skipping.`);
              return;
            }

            console.log(`Parent issue: #${parentIssueNumber}, PR: #${prNumber}, HEAD: ${headSha}`);

            // ── Step 2: Query sub-issues and check for blockers ─────────
            const subIssues = await getSubIssues(parentIssueNumber);
            console.log(`Found ${subIssues.length} sub-issues for #${parentIssueNumber}`);

            const openBlockers = subIssues.filter(si => {
              if (si.state !== 'OPEN') return false;
              const labels = si.labels.nodes.map(l => l.name);
              return labels.includes('blocking');
            });

            // ── Step 3: If blockers exist, report failing check ─────────
            if (openBlockers.length > 0) {
              const blockerList = openBlockers
                .map(si => `- #${si.number}: ${si.title}`)
                .join('\n');

              await createCheckRun(
                headSha,
                'action_required',
                `Orchestrator: ${openBlockers.length} blocking issue(s)`,
                [
                  `PR #${prNumber} cannot merge. Issue #${parentIssueNumber} has open blocking sub-issues:`,
                  '',
                  blockerList,
                  '',
                  'Resolve these blocking issues or approve the PR to override.'
                ].join('\n')
              );
              console.log(`Reported failing check: ${openBlockers.length} blockers.`);
              return;
            }

            // ── Step 4: No blockers — assess re-review need ─────────────
            console.log('No open blockers. Assessing re-review need...');

            const cycleCap = await readCycleCap();
            const pastCycles = await countReviewCycles(prNumber);
            console.log(`Review cycles so far: ${pastCycles}, cap: ${cycleCap}`);

            // If we've reached the cycle cap, pass without re-review
            if (pastCycles >= cycleCap) {
              await createCheckRun(
                headSha,
                'success',
                'Orchestrator: passing (review cycle cap reached)',
                [
                  `All blocking sub-issues for #${parentIssueNumber} are resolved.`,
                  '',
                  `Re-review cycle cap reached (${pastCycles}/${cycleCap}). No further re-review.`,
                  'PR is clear to merge.'
                ].join('\n')
              );
              console.log('Cycle cap reached. Reporting success.');
              return;
            }

            // For pull_request synchronize events (new commits pushed),
            // or when blockers just cleared, assess whether re-review is needed.
            // Use claude -p for the assessment.
            let needsReReview = false;

            try {
              // Get the PR details to find base branch
              const { data: prData } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              const baseBranch = prData.base.ref;

              // Get the diff stat to assess change scope
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100
              });

              const totalChanges = files.reduce(
                (sum, f) => sum + f.additions + f.deletions, 0
              );
              const fileCount = files.length;
              const fileList = files
                .map(f => `${f.filename} (+${f.additions}/-${f.deletions})`)
                .join('\n');

              // Only invoke claude if there's a meaningful diff
              if (totalChanges === 0) {
                console.log('No changes in PR. Skipping re-review assessment.');
                needsReReview = false;
              } else {
                // Build the assessment prompt
                const assessPrompt = [
                  'You are assessing whether a PR needs re-review after changes were made to address review findings.',
                  '',
                  `PR #${prNumber} targets branch "${baseBranch}" and fixes issue #${parentIssueNumber}.`,
                  `Past review cycles: ${pastCycles}`,
                  '',
                  `The PR modifies ${fileCount} files with ${totalChanges} total line changes:`,
                  fileList,
                  '',
                  'Based on the scope and nature of these changes, should reviewers re-review this PR?',
                  'Consider: Are the changes small and surgical (e.g., null checks, single test additions)?',
                  'Or are they broad and structural (e.g., new modules, architectural changes, many files)?',
                  '',
                  'Respond with ONLY one word: YES or NO',
                ].join('\n');

                // Run claude -p for the assessment
                const { execSync } = require('child_process');
                try {
                  const result = execSync(
                    `claude -p "${assessPrompt.replace(/"/g, '\\"')}"`,
                    { encoding: 'utf-8', timeout: 60000 }
                  ).trim();

                  console.log(`Claude assessment result: ${result}`);
                  needsReReview = /\bYES\b/i.test(result);
                } catch (claudeErr) {
                  console.log(`Claude assessment failed: ${claudeErr.message}`);
                  // If Claude fails, default to not needing re-review
                  // to avoid blocking the pipeline
                  needsReReview = false;
                }
              }
            } catch (err) {
              console.log(`Error during re-review assessment: ${err.message}`);
              needsReReview = false;
            }

            // ── Step 5: Trigger re-review or report passing ─────────────
            if (needsReReview) {
              console.log('Re-review warranted. Triggering PR Review workflow...');

              // Leave a marker comment for cycle counting
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: [
                  '<!-- orchestrator-review-cycle -->',
                  `**Orchestrator:** Triggering re-review (cycle ${pastCycles + 1}/${cycleCap}).`,
                  '',
                  'Changes since last review warrant another review pass.'
                ].join('\n')
              });

              // Trigger the PR Review workflow via workflow_dispatch
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'pr-review.yml',
                  ref: context.ref || 'main',
                  inputs: {
                    'pr-number': prNumber.toString()
                  }
                });
                console.log('PR Review workflow triggered successfully.');
              } catch (dispatchErr) {
                console.log(`Warning: Could not trigger PR Review workflow: ${dispatchErr.message}`);
              }

              await createCheckRun(
                headSha,
                'neutral',
                `Orchestrator: re-review triggered (cycle ${pastCycles + 1}/${cycleCap})`,
                [
                  `All blocking sub-issues for #${parentIssueNumber} are resolved.`,
                  '',
                  `Changes since last review warrant re-review. Cycle ${pastCycles + 1} of ${cycleCap} triggered.`,
                  'The PR Review workflow has been dispatched. Orchestrator will re-evaluate after review completes.'
                ].join('\n')
              );
            } else {
              console.log('No re-review needed. Reporting success.');

              await createCheckRun(
                headSha,
                'success',
                'Orchestrator: all clear',
                [
                  `All blocking sub-issues for #${parentIssueNumber} are resolved.`,
                  '',
                  pastCycles > 0
                    ? `No further re-review needed after ${pastCycles} review cycle(s).`
                    : 'No re-review warranted based on change assessment.',
                  '',
                  'PR is clear to merge.'
                ].join('\n')
              );
            }

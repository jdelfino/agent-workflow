name: "Guardrail: API Surface Changes"

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  checks: write
  pull-requests: read
  contents: read

jobs:
  api-surface-check:
    runs-on: ubuntu-latest
    steps:
      - name: Check API surface changes
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;
            const headSha = context.payload.pull_request.head.sha;
            const checkName = 'guardrail/api-surface';

            // --- Read config ---
            let enabled = true;
            let configuredConclusion = 'action_required';
            try {
              const configResponse = await github.rest.repos.getContent({
                owner,
                repo,
                path: '.github/agent-workflow/config.yaml',
                ref: headSha,
              });
              const configContent = Buffer.from(configResponse.data.content, 'base64').toString('utf8');
              // Simple YAML parsing for our config keys
              const enabledMatch = configContent.match(/api-surface:\s*\n\s*enabled:\s*(true|false)/);
              if (enabledMatch && enabledMatch[1] === 'false') {
                enabled = false;
              }
              const conclusionMatch = configContent.match(/api-surface:\s*\n\s*enabled:\s*(?:true|false)\s*\n\s*conclusion:\s*(\S+)/);
              if (conclusionMatch) {
                configuredConclusion = conclusionMatch[1];
              }
            } catch (e) {
              // Config file not found or unreadable — use defaults (enabled, action_required)
              core.info('No config.yaml found, using defaults (enabled: true, conclusion: action_required)');
            }

            if (!enabled) {
              await github.rest.checks.create({
                owner,
                repo,
                head_sha: headSha,
                name: checkName,
                status: 'completed',
                conclusion: 'success',
                output: {
                  title: 'API surface check: disabled',
                  summary: 'This check is disabled in config.yaml.',
                },
              });
              return;
            }

            // --- Check for non-stale PR approval override ---
            const reviews = await github.rest.pulls.listReviews({
              owner,
              repo,
              pull_number: prNumber,
            });
            const hasValidApproval = reviews.data.some(
              (r) => r.state === 'APPROVED' && r.commit_id === headSha
            );

            if (hasValidApproval) {
              await github.rest.checks.create({
                owner,
                repo,
                head_sha: headSha,
                name: checkName,
                status: 'completed',
                conclusion: 'success',
                output: {
                  title: 'API surface check: approved by reviewer',
                  summary: 'A non-stale PR approval overrides this guardrail.',
                },
              });
              return;
            }

            // --- Get PR files and scan for API surface changes ---
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: prNumber,
            });

            // API surface patterns — language-aware heuristics
            const apiPatterns = [
              // JavaScript / TypeScript
              { regex: /^\+.*\bexport\s+(default\s+)?(function|class|const|let|var|interface|type|enum)\b/, label: 'JS/TS export' },
              { regex: /^\+.*\bmodule\.exports\b/, label: 'CommonJS export' },
              { regex: /^\+.*\bexports\.\w+/, label: 'CommonJS named export' },
              // Python
              { regex: /^\+.*@app\.(route|get|post|put|delete|patch)\b/, label: 'Flask/FastAPI route' },
              { regex: /^\+.*@router\.(route|get|post|put|delete|patch)\b/, label: 'Router route' },
              // Go
              { regex: /^\+\s*func\s+[A-Z]/, label: 'Go exported function' },
              { regex: /^\+\s*type\s+[A-Z]\w+\s+(struct|interface)\b/, label: 'Go exported type' },
              // Java / Kotlin / C#
              { regex: /^\+.*\bpublic\s+(static\s+)?(class|interface|enum|void|int|string|boolean|long|double|float|[\w<>\[\]]+)\s+\w+/, label: 'Public declaration' },
              // Rust
              { regex: /^\+.*\bpub\s+fn\b/, label: 'Rust public function' },
              { regex: /^\+.*\bpub\s+(struct|enum|trait|type|mod)\b/, label: 'Rust public type' },
              // Ruby on Rails
              { regex: /^\+.*\b(get|post|put|patch|delete|resources|resource)\s+['":\/]/, label: 'Rails route' },
              // Express.js / Node.js
              { regex: /^\+.*\brouter\.(get|post|put|delete|patch|all|use)\s*\(/, label: 'Express route' },
              { regex: /^\+.*\bapp\.(get|post|put|delete|patch|all|use)\s*\(/, label: 'Express app route' },
            ];

            // OpenAPI / Swagger file patterns
            const openApiFilePatterns = [
              /openapi\.(ya?ml|json)$/i,
              /swagger\.(ya?ml|json)$/i,
              /api-spec\.(ya?ml|json)$/i,
            ];

            const annotations = [];
            let totalApiChanges = 0;

            for (const file of files) {
              // Skip removed files
              if (file.status === 'removed') continue;

              // Check if this is an OpenAPI/Swagger spec file
              const isOpenApiFile = openApiFilePatterns.some((p) => p.test(file.filename));
              if (isOpenApiFile) {
                totalApiChanges++;
                annotations.push({
                  path: file.filename,
                  start_line: 1,
                  end_line: 1,
                  annotation_level: 'warning',
                  message: `OpenAPI/Swagger spec file modified: ${file.filename}. API contract changes require careful review.`,
                });
                continue;
              }

              // Parse the patch for added lines matching API patterns
              if (!file.patch) continue;

              const lines = file.patch.split('\n');
              let currentLine = 0;

              for (const line of lines) {
                // Track line numbers from hunk headers
                const hunkMatch = line.match(/^@@\s+-\d+(?:,\d+)?\s+\+(\d+)(?:,\d+)?\s+@@/);
                if (hunkMatch) {
                  currentLine = parseInt(hunkMatch[1], 10);
                  continue;
                }

                // Only look at added lines (start with +, not +++)
                if (line.startsWith('+') && !line.startsWith('+++')) {
                  for (const pattern of apiPatterns) {
                    if (pattern.regex.test(line)) {
                      totalApiChanges++;
                      annotations.push({
                        path: file.filename,
                        start_line: currentLine,
                        end_line: currentLine,
                        annotation_level: 'warning',
                        message: `API surface change detected (${pattern.label}): ${line.substring(1).trim()}`,
                      });
                      break; // One annotation per line
                    }
                  }
                }

                // Advance line counter for added and context lines (not removed lines)
                if (!line.startsWith('-')) {
                  currentLine++;
                }
              }
            }

            // --- Report results ---
            if (totalApiChanges === 0) {
              await github.rest.checks.create({
                owner,
                repo,
                head_sha: headSha,
                name: checkName,
                status: 'completed',
                conclusion: 'success',
                output: {
                  title: 'API surface check: no changes detected',
                  summary: 'No API surface changes found in this PR.',
                },
              });
            } else {
              // GitHub API limits annotations to 50 per call
              const batchSize = 50;
              const batches = [];
              for (let i = 0; i < annotations.length; i += batchSize) {
                batches.push(annotations.slice(i, i + batchSize));
              }

              const summary = [
                `Found ${totalApiChanges} API surface change(s) across the PR.`,
                '',
                'API surface changes have outsized downstream impact. Review these changes carefully.',
                '',
                'To override: approve the PR to signal these changes are intentional.',
              ].join('\n');

              // Create the check run with the first batch of annotations
              const checkRun = await github.rest.checks.create({
                owner,
                repo,
                head_sha: headSha,
                name: checkName,
                status: 'completed',
                conclusion: configuredConclusion,
                output: {
                  title: `API surface check: ${totalApiChanges} change(s) detected`,
                  summary,
                  annotations: batches[0] || [],
                },
              });

              // If there are more annotations, update the check run with additional batches
              for (let i = 1; i < batches.length; i++) {
                await github.rest.checks.update({
                  owner,
                  repo,
                  check_run_id: checkRun.data.id,
                  output: {
                    title: `API surface check: ${totalApiChanges} change(s) detected`,
                    summary,
                    annotations: batches[i],
                  },
                });
              }
            }

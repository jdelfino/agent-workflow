name: "Guardrail: Commit Messages"

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  checks: write
  contents: read
  pull-requests: read

jobs:
  commit-messages:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check commit messages
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // --- Read config ---
            // Default conclusion for commit message guardrail is 'neutral' (non-blocking warning)
            let configuredConclusion = 'neutral';
            const configPath = path.join(process.env.GITHUB_WORKSPACE, '.github', 'agent-workflow', 'config.yaml');
            try {
              const configContent = fs.readFileSync(configPath, 'utf8');
              // Simple YAML parsing for the guardrails.commit-messages section
              // Config structure: guardrails: > commit-messages: > enabled/conclusion
              const lines = configContent.split('\n');
              let inGuardrails = false;
              let inCommitSection = false;
              let guardrailIndent = 0;
              let commitIndent = 0;
              for (const line of lines) {
                // Detect guardrails: top-level key
                if (/^guardrails:/.test(line)) {
                  inGuardrails = true;
                  inCommitSection = false;
                  continue;
                }
                // If we hit another top-level key, leave guardrails
                if (inGuardrails && /^\S/.test(line) && !/^\s*#/.test(line) && line.trim() !== '') {
                  inGuardrails = false;
                  inCommitSection = false;
                  continue;
                }
                // Inside guardrails, look for commit-messages:
                if (inGuardrails && !inCommitSection) {
                  const commitMatch = line.match(/^(\s+)commit-messages:/);
                  if (commitMatch) {
                    inCommitSection = true;
                    commitIndent = commitMatch[1].length;
                    continue;
                  }
                }
                // If in commit section, check for sibling keys (same indent = new section)
                if (inCommitSection) {
                  const lineIndent = line.match(/^(\s*)/)[1].length;
                  if (line.trim() === '' || /^\s*#/.test(line)) continue;
                  if (lineIndent <= commitIndent) {
                    // Left the commit-messages section
                    inCommitSection = false;
                    continue;
                  }
                  const conclusionMatch = line.match(/^\s+conclusion:\s*(\S+)/);
                  if (conclusionMatch) {
                    const val = conclusionMatch[1].replace(/['"]/g, '');
                    if (['success', 'neutral', 'action_required'].includes(val)) {
                      configuredConclusion = val;
                    }
                  }
                  const enabledMatch = line.match(/^\s+enabled:\s*(\S+)/);
                  if (enabledMatch) {
                    const val = enabledMatch[1].replace(/['"]/g, '').toLowerCase();
                    if (val === 'false') {
                      // Check is disabled, report success and exit
                      await github.rest.checks.create({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        head_sha: context.sha,
                        name: 'guardrail/commit-messages',
                        conclusion: 'success',
                        output: {
                          title: 'Commit message check: disabled',
                          summary: 'This guardrail check is disabled in config.yaml.'
                        }
                      });
                      return;
                    }
                  }
                }
              }
            } catch (e) {
              // No config file found — use defaults (neutral)
              core.info(`No config.yaml found at ${configPath}, using default conclusion: neutral`);
            }

            // --- Check for non-stale PR approval override ---
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });

            const headSha = context.payload.pull_request.head.sha;
            const hasValidApproval = reviews.data.some(
              r => r.state === 'APPROVED' && r.commit_id === headSha
            );

            if (hasValidApproval) {
              await github.rest.checks.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head_sha: context.sha,
                name: 'guardrail/commit-messages',
                conclusion: 'success',
                output: {
                  title: 'Commit message check: approved by reviewer',
                  summary: 'A non-stale PR approval overrides this guardrail check.'
                }
              });
              return;
            }

            // --- Get PR commits ---
            const commits = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              per_page: 100
            });

            // --- Validate each commit message ---
            // Conventional commit regex: type(optional scope)optional !: description
            const conventionalCommitRegex = /^(feat|fix|chore|docs|test|refactor|ci|style|perf|build|revert)(\(.+\))?!?: .+/;
            const maxFirstLineLength = 72;

            const violations = [];

            for (const commit of commits.data) {
              const message = commit.commit.message;
              const firstLine = message.split('\n')[0];
              const sha = commit.sha.substring(0, 7);
              const commitViolations = [];

              // Check conventional commit format
              if (!conventionalCommitRegex.test(firstLine)) {
                commitViolations.push(
                  `Does not follow conventional commit format (expected: type(scope)?: description)`
                );
              }

              // Check first line length
              if (firstLine.length > maxFirstLineLength) {
                commitViolations.push(
                  `First line exceeds ${maxFirstLineLength} characters (${firstLine.length} chars)`
                );
              }

              if (commitViolations.length > 0) {
                violations.push({
                  sha: sha,
                  fullSha: commit.sha,
                  firstLine: firstLine,
                  issues: commitViolations
                });
              }
            }

            // --- Report results ---
            const totalCommits = commits.data.length;
            const nonConformingCount = violations.length;

            if (nonConformingCount === 0) {
              // All commits conform
              await github.rest.checks.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head_sha: context.sha,
                name: 'guardrail/commit-messages',
                conclusion: 'success',
                output: {
                  title: `Commit message check: all ${totalCommits} commits conform`,
                  summary: `All ${totalCommits} commit(s) follow conventional commit format with first line <= ${maxFirstLineLength} characters.`
                }
              });
              return;
            }

            // Build summary with non-conforming commits
            let summary = `## Non-conforming commits\n\n`;
            summary += `Found **${nonConformingCount}** of ${totalCommits} commit(s) with violations:\n\n`;

            for (const v of violations) {
              summary += `### \`${v.sha}\` — ${v.firstLine}\n`;
              for (const issue of v.issues) {
                summary += `- ${issue}\n`;
              }
              summary += '\n';
            }

            summary += `\n## Expected format\n\n`;
            summary += '```\n';
            summary += 'type(optional-scope): description (max 72 chars)\n';
            summary += '```\n\n';
            summary += `Valid types: \`feat\`, \`fix\`, \`chore\`, \`docs\`, \`test\`, \`refactor\`, \`ci\`, \`style\`, \`perf\`, \`build\`, \`revert\`\n\n`;
            summary += `**Configured conclusion:** \`${configuredConclusion}\`\n`;
            summary += `\nTo override: submit an approving PR review. The approval must be on the current head commit to be non-stale.\n`;

            // Use the configured conclusion (default: neutral = non-blocking warning)
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: context.sha,
              name: 'guardrail/commit-messages',
              conclusion: configuredConclusion,
              output: {
                title: `Commit message check: ${nonConformingCount} non-conforming commit(s)`,
                summary: summary
              }
            });
